"""
Consumer program that processes outputs generated by the producer.
This program continuously monitors the queue and processes files as they become available.
"""

import sys
import time
from pathlib import Path
from typing import Optional

# Add project root to path to enable imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from src.queue_manager import QueueManager


def process_file(file_path: str) -> bool:
    """
    Process a single output file.
    
    This is a template function - replace with your actual processing logic.
    
    Args:
        file_path: Path to the file to process
        
    Returns:
        True if processing was successful, False otherwise
    """
    file_path_obj = Path(file_path)
    
    if not file_path_obj.exists():
        print(f"Warning: File does not exist: {file_path}")
        return False
    
    try:
        # TODO: Add your processing logic here
        # Example: Load image, perform analysis, save results, etc.
        
        print(f"Processing: {file_path}")
        
        # Example processing (replace with your actual logic):
        # - Load the image/file
        # - Perform your analysis/transformation
        # - Save results if needed
        
        # For demonstration, we'll just simulate processing
        time.sleep(0.1)  # Simulate processing time
        
        print(f"Successfully processed: {file_path}")
        return True
        
    except Exception as e:
        print(f"Error processing {file_path}: {e}")
        return False


def main(
    queue_db_path: str = "output_queue.db",
    poll_interval: float = 1.0,
    cleanup_on_exit: bool = True
):
    """
    Main consumer function.
    
    Args:
        queue_db_path: Path to queue database file (must match producer)
        poll_interval: Seconds to wait between queue checks when no items available
        cleanup_on_exit: If True, remove entries for missing files on exit
    """
    # Initialize queue manager
    queue_manager = QueueManager(db_path=queue_db_path, max_unprocessed=10)
    print(f"Consumer started (polling every {poll_interval}s)")
    print("Press Ctrl+C to stop\n")
    
    try:
        while True:
            # Get next pending file
            file_path = queue_manager.get_next_pending()
            
            if file_path is None:
                # No pending files, wait and check again
                time.sleep(poll_interval)
                continue
            
            # Mark as processing to prevent other consumers from picking it up
            if not queue_manager.mark_processing(file_path):
                # File was already taken by another consumer or removed
                continue
            
            # Process the file
            success = process_file(file_path)
            
            if success:
                # Mark as completed and remove from queue
                queue_manager.mark_completed(file_path)
                
                # Delete the processed file
                try:
                    Path(file_path).unlink()
                    print(f"Deleted processed file: {file_path}\n")
                except Exception as e:
                    print(f"Warning: Could not delete file {file_path}: {e}\n")
            else:
                # Processing failed - you might want to handle this differently
                # For now, we'll remove it from the queue to avoid blocking
                print(f"Processing failed for {file_path}, removing from queue\n")
                queue_manager.mark_completed(file_path)
            
    except KeyboardInterrupt:
        print("\nConsumer stopped by user")
    except Exception as e:
        print(f"Error in consumer: {e}")
    finally:
        if cleanup_on_exit:
            print("Cleaning up missing file entries...")
            queue_manager.cleanup_missing_files()
        print("Consumer exited")


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Consumer program for processing outputs")
    parser.add_argument(
        "--queue-db",
        type=str,
        default="output_queue.db",
        help="Path to queue database file (default: output_queue.db)"
    )
    parser.add_argument(
        "--poll-interval",
        type=float,
        default=1.0,
        help="Seconds to wait between queue checks (default: 1.0)"
    )
    parser.add_argument(
        "--no-cleanup",
        action="store_true",
        help="Don't cleanup missing file entries on exit"
    )
    
    args = parser.parse_args()
    
    main(
        queue_db_path=args.queue_db,
        poll_interval=args.poll_interval,
        cleanup_on_exit=not args.no_cleanup
    )

